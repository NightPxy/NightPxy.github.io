
* content
{:toc}


## 高并发架构    

数据库问题,写入,读写分离  
缓存
负载均衡,异步处理与并行处理  

### 架构  

* gateway 服务入口(只有三个接口,提单,查询,回调)  
提单:订单基本判断,验签,判重,收单入库(暂存库)  
查询:缓存  
* 暂存库扫描  
暂存库移入主库,同时发送MQ消息,订单正式开始流转  
* 订单环节   
构建大量的微服务 所有订单环节全是服务订阅MQ消息完成
横向上切分为充值环节,通知环节,保障环节  
纵向上每个环节都是横向扩展(多进程+多线程)  

环节内部保持节点一致性(首充,次充,三充,延时队列等待)是由同一个环节服务根据订单状态进行不同的处理  
保持节点一致性是为了部署维护方便,根据订单状态判断执行是为了保持过程的状态无关性(因为处理过程是完全依赖消息订阅的,这个过程我们规定:消息允许多发,允许漏发,要求系统必须适应这种情况) 多发的解决方案是消息环节处理幂等   
这个幂等主要是充值环节幂等(通知环节没有幂等,因为重复通知没有危害),解决方案是充值流水号 
漏发的解决方案是保障体系  
每个订单从开始就会有一条保障监控线(3分钟MQ延时消息),根据保障规则(如果非终结订单消息,三充通道如果不是终结通道,在指定时间内没有充值流水就会自发一条充值消息(仅仅发出消息,这个消息跟普通充值相同,保障不带任何充值逻辑))  
这个保障监控还有个作用是超时订单预警(基于充值承诺1小时内完成,在这之前就发出告警消息给运营)  

真正的充值过程是在子系统完成,也就是充值能力部分  
这部分是采用类似EDA架构,每个子系统比照COP设定`收单`,`查询`  
在COP中按照子系统的要求,每个订单组装成子系统格式提交(Http形式)  


架构衍生  
* 安全  
签名校验  
* 高可用  
keepalived 设置虚拟 IP 环境，实现IP漂移
消息本身的无状态,所以是基于消息订阅的高可用  
* 熔断  
人工熔断  
* 服务降级  
这里比较薄弱,只能算人工降级  
提供的是半实时的通道监控报表,然后人工处理(对下拒单,对上切换通道等等)  
也没有引入内存缓存的自动降级  
* 监控部分  
商户系:订单平均耗时,最长耗时,成功率,卡单数   
通道系:订单平均耗时,最长耗时,成功率,卡单数  
订单统一生命周期日志,订单从创建开始,它的每个阶段推进,环节的充值请求,响应回调等都会记录日志,

### 业务架构  

对下游视为一个商户,将每一次充值视为一个订单,每一个充值环节视为充值流水,每一种充值渠道视为一个通道  
业务抽象为订单,经过多次充值过程后产生一个最终结果  

### 数据库  

#### 高并发写入  

订单号采用的自增Id,一秒订单超过2000  
这样的好处是始终从尾页追加避免页分裂,劣势是尾页有数据热点问题  
解决的办法是多表写入然后再批量移入  
* 外部订单号取模写入10张暂存表中的一张表  
* 每个暂存表有一个独立服务批量读取整体移入订单主表  

#### 读写分离  

主库  
* 订单创建时间维度分区表  
* 订单表除了主键聚集索引之外,不使用任何索引,主库只能使用根据订单号查询单条订单  

从库  
* 所有查询以及辅助索引全部由从库解决  

### 缓存  

#### Redis  

Redis缓存主要用来做订单缓存  
* 失效抖动(雪崩)   
基于订单粒度的Redis缓存不太可能出现雪崩  
* 命中率(穿透)  
主要针对的是订单号不存在的情况,这时会写一个特殊字串`*NIL*`作为标记并进行正常缓存.同时设置这种空存在标志型的缓存过期时间设置为30秒(正常的订单缓存为5分钟)  
* 一致性  
双删机制,但总的来说对于一致性要求不高  
对于不存在订单30秒后必查一次(对外要求5分钟后订单不存在才视为不存在)  
对于存在的订单只有初始化,充值中和终结状态,只要最终一致(最终得到终结状态),中途出现几次脏的充值中没什么影响  
对于一致性不高的情况甚至可以使用多级缓存(内存缓存15秒),不过从现在来看足够用了  

####  SqlServer依赖缓存  

SqlServer依赖缓存用来做配置级别的缓存(比如通道配置等等)  
SqlServer依赖缓存是一种SqlServer特有机制,它是在客户端就维持一个与SqlServer的长连接,客户端会在内存中维持一个DataTable来映射一个某一张表,它的机制是SqlServer会把这张表的新增修改删除全部推送到客户端中  

### 服务器优化的常规思路  

* 空间换时间  
对热点数据缓存，减少数据查询时间  
* 分而治之   
将大任务切片，分开执行。HDFS、MapReduce就是这个原理  
* 异步处理  
若业务链中有某一环节耗时严重，则该环节将拉长业务链的整体耗时。可以将耗时业务采用消息队列异步化，从而缩短业务链耗时  
* 并行处理   
采用多进程、多线程同时处理，提升处理速度  
* 离用户更近一点  
如CDN技术，将静态资源放到离用户更近的地方，从而缩短请求静态资源的时间  
* 提升可扩展性  
采用业务模块化、服务化的手段，提升系统的可扩展性，从而可根据业务需求实现弹性计算

CPU 
CPU使用率过高的原因：

计算量大
非空闲等待
过多的系统调用
过多的中断
内存 
内存使用率过高的原因：

过多的页交换
可能存在内存泄露
IO 
IO繁忙的原因：

读写频繁 
磁盘的读写过程是物理动作，频繁的读写势必会使IO来不及处理。
https://zhuanlan.zhihu.com/p/34266039