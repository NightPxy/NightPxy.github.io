---
layout: post
title:  "Spark-JVM调优"
date:   2018-10-09 13:31:01 +0800
categories: spark
tag: spark
---

* content
{:toc}


## 概述  

Spark每个执行节点,无论driver还是executor,本质都是一个JVM进程  
适当的对JVM进行调优,对Spark的任务执行是可能带来相当大的好处的  

## JVM 结构  

JVM的内存结构主要是三大块  堆内存,方法区和栈  

* 方法区  
存储类型信息,静态变量等等  
* 栈  
就是执行方法栈  
* 堆内存  
整个堆内存将分为两大块,新生代和老年代,新生代由分为Eden,From Survivor,To Survivor三块
默认情况下: 年轻代按照8:1:1的配比分配  

### 堆  

堆负责分配和存放JVM中几乎所有的对象实例  
这是所有线程共享的区域,也应该是JVM中占比最大的部分  

堆是垃圾回收器的主要工作对象,因为很多时候也被称为GC堆  
如果一个堆当前无法分配出一个实例,并且自身也无法通过GC回收或者扩展堆自身大小来分配出一个实例,则会抛出一个OutOfMemory的异常,这就是熟知的OOM  

### 方法区  

方法区用于存储被JVM加载的类信息,方法信息,静态变量等等 
这也是所有线程共享的区域  
方法区还有个名字叫永生代,被称为堆的一部分.本质上,方法区应该是与堆平级的有特殊对待的内存分配区  

特殊之处在于,GC一般不进入方法区工作(所以被称为永生代).  
但这个永生并非是指永远存在,方法区有自己回收机制.比如类型卸载,常量回收等等  

但一般来说也算是永生了,因为诸如类型卸载,条件相当苛刻,所以永生代的回收通常都不满意  

永生代无法分配,同样会抛出OOM

### 程序计数器  



### 栈  

栈其实有两种栈, JVM栈和本地方法栈  

#### JVM 栈  

JVM栈,是线程私有的,生命周期与线程相同.
JVM栈描述的方法执行过程:每个方法执行都会生成一个调用栈用于存储局部变量列表,操作栈,方法出口等,每一个方法被调用直至执行完成,就是一个调用栈从JVM栈从入栈到出栈的过程  

对栈来说,线程请求的栈深度大于了虚拟机所允许的最大深度,将抛出StackOutFlowError  

#### 本地方法栈  

本地方法栈与JVM栈本质相同,只是是以JVM走一些native语言执行使用的调用栈  


## JVM 的控制参数  

|参数|描述|
|---|---|
|-Xms|设置堆的最小空间大小|
|-Xmx|设置堆的最大空间大小|
|-XX:NewSize|设置堆的新生代空间大小|
|-XX:MaxNewSize|设置堆的最大新生代空间大小|
|-XX:PermSize|设置永生代的空间大小|
|-XX:MaxPermSize|设置永生代最大空间的大小|
|-Xss|设置每个线程的堆栈大小|

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制  
老年代空间大小=堆空间大小-年轻代大空间大小  

## GC  

-XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version

调JVM,一般是两个目的的平衡 响应能力和吞吐量   
* 响应能力指一个程序或者系统对请求是否能够及时响应  
关注响应能力的系统,不能接受某次长时间的停顿.即可以接受100次100毫秒的停顿,但不能接受1次5秒的停顿  
* 吞吐量指一个指定时间内,最大化一个应用的工作量  
关注吞吐量的系统,可以接受某次5秒的停顿,但不能接收100次100毫秒(共计10秒)的停顿  

调优JVM的GC部分核心,就是在更频繁或更长GC的STM中,找出一个最适合自己的平衡  

### 概述  

GC(Garbage Collection),垃圾回收   
在JVM中,GC负责新的对象分配空间,和回收不再使用的对象以释放内存继续分配给新的对象  
GC的主要工作对象是堆,永生代有自己独特的回收机制,调用栈和程序计数器,会随着线程执行完毕自动回收  

### 对象存活  

GC判断是否应该回收该对象的依据是对象是否存活.一般有两种依据  
* 引用计数器  
每个对象都有一个引用计数器,每有一个其它对象引用该对象则计数器加一,释放时减一,然后回收0计数的对象,这种判断的缺点是无法识别循环引用的对象而导致内存泄露  
* 到达路径标记  
从一个根开始,根据引用路径遍历所有的对象,凡是遍历到的对象全部标记一次.然后回收所有没有被标记的对象(无法访问的对象,就视为垃圾对象).  
GC扫描的起点根包括:栈上的引用(调用方法内引用),永生代上的类静态类型引用和常量区引用等  

### 回收算法  

#### 标记-清除算法  

算法分为标记,然后清除两部分  
这是最基础的算法了,后续算法都是针对标记清除算法的确定来演进的  
它的缺点  
* 效率不高  
无论标记过程,还是清除过程,效率都不高.效率不高,则意味着GC的耗时更长,停顿时间也更长  
* 会产生大量的不连续空间碎片,会导致可能分配不出一个连续的大对象空间而不得不提前触发一次GC  

#### 复制算法  

复制算法是将内存空间分为两块(各50%),每次GC都会把剩余对象全部移动到另一边 
这样分配时将使用在一块连续空间分配,效率更高
缺点  
* 内存天然只能使用一半,极大的浪费空间  
* 分配效率更高了,并且如果存活率相对高的话会导致GC过程更慢了   

#### 标记-整理算法  

与标记-清除相同,但清除完毕会将剩余对象全部前移成一个连续部分  

比复制算法的好处在于至少可以使用100%空间,但如果存活率依然有GC缓慢的特点  

#### 分代算法  

将堆分为几代(新生代和老年代),然后对每代分别使用不同的算法策略

###  GC产品  

#### Serial GC  

串行收集器是最古老,最稳定的收集器  
它是默认Client模式的新生代回收器  
串行收集器是一个单线程,在收集时会暂停整个JVM  


优点:
* 使用简单,对于单CPU,由于没有多线程的交互开销,可能会有奇效  

参数控制:

```java
-XX:+UseSerialGC  //串行收集器
会使用 Serial + Serial Old 的收集器组合  
新生代使用复制算法,老年代使用标记整理算法  
```

#### ParNew GC  

ParNew 其实就是 Serial 的多线程版本  

* 使用多线程进行GC,在GC时会停止整个JVM  
* 在并发能力好的环境下,它停顿的时间比串行要短,但如果环境本身的并发能力弱,由于多线程的交互开销,可能会比串行更差  
* 是Server模式的下默认新生代收集器,且能和CMS收集器配合使用  
* 新生代使用复制算法,老年代使用标记整理算法  

```java
-XX:+UseParNewGC 启用ParNew收集器
-XX:ParallelGCThreads 限制线程数量
```

#### Parallel GC 

Parallel 类似 PareNew 收集器,但Parallel更关注吞吐量.
可以通过参数来打开自适应调节策略,虚拟机会根据当前系统的运行情况收集性能监控信息,动态调整这些参数以提供最合适的停顿时间或最大吞吐量,也可以通过参数控制GC的时间不大于多少毫秒或者比例,比如新生代复制算法,老年代标记-压缩  

```java
-XX:+UseParallelGC 启用新生代Parallel GC
-XX:+UseParallelOldGC 启用老年代Parallel GC
-xx:GCTimeRadio 指定运行应用代码的时间占总应用时间的比例,默认99%,即1%时间用来GC
-xx:MaxGCPauseMillis:设置GC最大停顿时间  
新生代使用复制算法,老年代使用标记-整理算法
```

#### CMS GC  

***概述***
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验  

***回收步骤***
CMS收集器是基于“标记-清除”算法实现的,整个步骤分为4步:  
* 初始标记（CMS initial mark,STW）  
初始标记扫描Roots能直接关联的对象,这一步比较快,但会STW  
* 并发标记（CMS concurrent mark）  
并发标记是根据初始标记的标记对象继续扫描.并发是指不会STW,用户线程会继续执行
* 重新标记（CMS remark, STW）  
重新标记是修正在并发标记节点用户线程继续执行所产生的引用变更等情况的修正.  
会STW,且时间一般会长于初始标记停顿,但远小于整个并发标记的时间  
* 并发清除（CMS concurrent sweep）  
根据修正后的标记开始清理,不会STW,用户线程会继续执行  

***优点***
* 最低的停顿时间  
使用于要求高响应速度,不能接受稍长的系统停顿时间的情况  

***缺点***
* 会产生大量内存碎片空间  
CMS是无法立即执行内存整理,所以会产生大量内存碎片.只能在GC N次或者老年代满的情况下以STW的方式内存整理  
* 在并发标记和并发清理阶段,多线程会占用一定CPU资源而导致可能的应用程序吞吐量下降  
默认GC线程数量是 (CPU个数+3)/4 即2核1个,5核2个  
* 会产生浮动垃圾,且当突然产生大量浮动垃圾时会分配失败,此时会被迫启用seral-old重新GC  
浮动垃圾是指在CMS在并发清除阶段,因为用户线程的继续执行而产生的新的垃圾.这部分垃圾无法在本次GC中处理(甚至都不一定开始清理),所以只能放入预留空间.  
但如果某个时刻用户线程产生了大量的对象,而导致预留空间放不下,此时会启用seral-old重新GC(STW)
* CMS基于标记-清理的算法实现的，所以会导致old-Gen内存碎片。当内存碎片过多或者年轻带晋升太多,CMS未完成时oldGen已经满了，则会产生concurrent mode failure 然后切换为SerialOld(mark-sweep-compact 带整理内存碎片)  

***常用优化***

*-XX:+UseConcMarkSweepGC*  
使用CMS收集器

*-XX:CMSInitiatingOccupancyFraction=70*  
设定CMS在对内存占用达到70%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC)   
*-XX:+UseCMSInitiatingOccupancyOnly*  
只是用设定的回收阈值(上面指定的70%),如果不指定,JVM仅在第一次使用设定值,后续就失效了  

*-XX:+CMSScavengeBeforeRemark*  
在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销  
一般CMS的GC耗时 80%都在remark阶段  

*-XX:+CMSFullGCsBeforeCompaction*  
设置进行几次Full GC后，进行一次碎片整理  

*-XX:ParallelCMSThreads*  
设定CMS的线程数量（一般情况约等于可用CPU数量）  

#### G1 GC

***优势***
* Region基于Copy算法的自动空间整合,不容易产生内存空间碎片.  
* 分配大对象容易找到一片连续空间分配  
* 始终保持对部分Region的,停顿时间短  
* 可预测停顿  
降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了  

***设计***
* G1取消原来不同代的物理隔离,而会将整个内存空间分为很多很多大小相等的块(Region).  
* 这些块(Region)本身有新生代,老年代的身份但彼此不一定保持连续.  
* 引入一个特殊的Region:大对象区(Humongous),专门用来存放占Region超过50%的大对象  
大对象区一般认为是老年代中的一部分  

***内存分配***  
* TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区  
TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针.在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步  
* 如果TLAB不够用，则在Eden中分配内存生成对象,如果Eden依然不够,就会尝试老年区  
* 如果是大对象,会直接在大对象区分配  

G1的回收步骤  
G1提供两种GC模式,Young GC和Mixed GC (两种都会STW)  
* Young GC  
当eden数据满了,则触发G1 YGC  
并行执行,将 eden region 中存活的对象拷贝到survivor,或者直接晋升到Old Region中；将Survivor Regin中存活的对象拷贝到新的Survivor或者晋升old region  

*Mixed GC*  
在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节  
* 初始标记（initial mark，STW）  
在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关  
* 根区域扫描（root region scan） 
G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收  
* 并发标记（Concurrent Marking） 
G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断  
* 最终标记（Remark，STW）  
该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理  
* 清除垃圾（Cleanup，STW）  
在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发  

*g1 对老年代回收*
* 并发标记阶段(Concurrent Marking Phase)  
在不产生stop-the-world，与程序进程并发的情况下，活跃度（可达性分析）被分析出来。 
活跃度越低，代表回收的效率越高，越值得优先回收  
* 复制、清理阶段(Copying/Cleanup Phase)  
年轻代、老年代在这个阶段同时被回收掉。老年代被回收的region，是根据这个region的存活度来选择的  

***调优参数***  

*-XX：+UseG1GC*  
启用G1 GC,JDK7和JDK8要求必须显示申请启动G1 GC  

*-XX：G1NewSizePercent*  
初始年轻代占整个Java Heap的大小，默认值为5%  

*-XX：G1MaxNewSizePercent*  
最大年轻代占整个Java Heap的大小，默认值为60%  

*-XX：G1HeapRegionSize*  
设置每个Region的大小，单位MB，需要为1，2，4，8，16，32其一,默认是堆内存的1/2000  
如果这个值设置比较大,那么大对象就可以进入Region了,坏处是直接干预了各年龄代的分配大小  

*-XX：ConcGCThreads*  
与Java应用一起执行的GC线程数量。默认是Java线程的1/4  
减少这个参数的数值可能会提升并行回收的效率，即提高系统内部吞吐量（系统是一个整体，CPU资源大家都需要占用），不过如果这个数值过低，也会导致并行回收机制耗时加长  

*-XX：+InitiatingHeapOccupancyPercent(简称IHOP)*  
G1内部并行循环启动的设置值，默认为Java Heap的45%,可以理解为老年代空间占用的空间，GC收集后需要低于45%的占用率  
这个值主要是为了决定在什么时间启动老年代的并行回收循环，这个循环从初始化并行回收开始，可以避免Full GC的发生  

*-XX：G1HeapWastePercent*  
G1不会回收的内存大小，默认是堆大小的5%  
GC会收集所有的Region，如果值达到5%，就会停下来不再收集了  

*-XX：G1MixedGCCountTarget*  
设置并行循环之后需要有多少个混合GC启动，默认值是8个  
老年代Regions的回收时间通常比年轻代的收集时间要长一些，所以如果混合收集器比较多，可以允许G1延长老年代的收集时间  

*-XX：G1ReservePercent*  
这个值是为了保留一些空间用于年代之间的提升，默认值是堆空间的10%  
注意这个空间保留后就不会用在年轻代了，大家可以看到GC日志里输出显示，我们大量执行的是年轻代回收，所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，那还是减少一点保留空间吧，这样会给年轻代更多的预留空间、GC之间更长的处理时间；  

*-XX：+GCTimeRatio*  
GC的有些阶段是需要STW，即停止应用线程的.这个参数就是控制应用线程和GC线程的比率  
默认为9 计算公式 100/(1+VALUE)  即最多花10%时间花在GC上  

*-XX：+UseStringDeduplication*  
手动开启Java String对象的分割工作，这个是JDK8u20之后新增的参数，主要用于相同String避免重复申请内存，节约Region的使用  

*-XX：MaxGCPauseMills*  
G1停止执行的一个目标值，单位是毫秒，默认是200毫秒，这个值不一定真的会达到。这个参数会通过控制年轻代的大小来实现目标


*-XX：+G1SummarizeRSetStats*  
这个也是一个VM的调试信息。如果启用，会在VM推出的时候打印出RSets的详细总结信息。如果启用-XX：G1SummaryRSetStatsPeriod参数，就会阶段性地打印RSets信息  

*-XX：+G1TraceConcRefinement*  
这个也是一个VM的调试信息。如果启用，并行回收阶段的日志就会被详细打印出来  


*-XX：+G1PrintRegionLivenessInfo *  
这个参数需要和-XX：+UnlockDiagnosticVMOptions配合启动，这可以理解，它们本身就是属于VM的调试信息。如果开启了，VM会打印堆内存里每个Region的存活对象信息。这个信息在标记循环结束后可以打印出来；  

在线GC日志分析 http://gceasy.io 
在线dump文件分析 http://fastthread.io/ 



https://blog.csdn.net/lemon89/article/details/69056246
https://www.cnblogs.com/qingyunzong/p/8973857.html