---
layout: post
title:  "Spark-JVM调优"
date:   2018-06-09 13:31:01 +0800
categories: spark
tag: spark
---

* content
{:toc}


## 概述  

Spark每个执行节点,无论driver还是executor,本质都是一个JVM进程  
适当的对JVM进行调优,对Spark的任务执行是可能带来相当大的好处的  

## JVM 结构  

JVM的内存结构主要是三大块  堆内存,方法区和栈  

* 方法区  
存储类型信息,静态变量等等  
* 栈  
就是执行方法栈  
* 堆内存  
整个堆内存将分为两大块,新生代和老年代,新生代由分为Eden,From Survivor,To Survivor三块
默认情况下: 年轻代按照8:1:1的配比分配  

### 堆  

堆负责分配和存放JVM中几乎所有的对象实例  
这是所有线程共享的区域,也应该是JVM中占比最大的部分  

堆是垃圾回收器的主要工作对象,因为很多时候也被称为GC堆  
如果一个堆当前无法分配出一个实例,并且自身也无法通过GC回收或者扩展堆自身大小来分配出一个实例,则会抛出一个OutOfMemory的异常,这就是熟知的OOM  

### 方法区  

方法区用于存储被JVM加载的类信息,方法信息,静态变量等等 
这也是所有线程共享的区域  
方法区还有个名字叫永生代,被称为堆的一部分.本质上,方法区应该是与堆平级的有特殊对待的内存分配区  

特殊之处在于,GC一般不进入方法区工作(所以被称为永生代).  
但这个永生并非是指永远存在,方法区有自己回收机制.比如类型卸载,常量回收等等  

但一般来说也算是永生了,因为诸如类型卸载,条件相当苛刻,所以永生代的回收通常都不满意  

永生代无法分配,同样会抛出OOM

### 程序计数器  



### 栈  

栈其实有两种栈, JVM栈和本地方法栈  

#### JVM 栈  

JVM栈,是线程私有的,生命周期与线程相同.
JVM栈描述的方法执行过程:每个方法执行都会生成一个调用栈用于存储局部变量列表,操作栈,方法出口等,每一个方法被调用直至执行完成,就是一个调用栈从JVM栈从入栈到出栈的过程  

对栈来说,线程请求的栈深度大于了虚拟机所允许的最大深度,将抛出StackOutFlowError  

#### 本地方法栈  

本地方法栈与JVM栈本质相同,只是是以JVM走一些native语言执行使用的调用栈  


## JVM 的控制参数  

|参数|描述|
|---|---|
|-Xms|设置堆的最小空间大小|
|-Xmx|设置堆的最大空间大小|
|-XX:NewSize|设置堆的新生代空间大小|
|-XX:MaxNewSize|设置堆的最大新生代空间大小|
|-XX:PermSize|设置永生代的空间大小|
|-XX:MaxPermSize|设置永生代最大空间的大小|
|-Xss|设置每个线程的堆栈大小|

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制  
老年代空间大小=堆空间大小-年轻代大空间大小  

## GC  

### 概述  

GC(Garbage Collection),垃圾回收   
在JVM中,GC负责新的对象分配空间,和回收不再使用的对象以释放内存继续分配给新的对象  
GC的主要工作对象是堆,永生代有自己独特的回收机制,调用栈和程序计数器,会随着线程执行完毕自动回收  

### 对象存活  

GC判断是否应该回收该对象的依据是对象是否存活.一般有两种依据  
* 引用计数器  
每个对象都有一个引用计数器,每有一个其它对象引用该对象则计数器加一,释放时减一,然后回收0计数的对象,这种判断的缺点是无法识别循环引用的对象而导致内存泄露  
* 到达路径标记  
从一个根开始,根据引用路径遍历所有的对象,凡是遍历到的对象全部标记一次.然后回收所有没有被标记的对象(无法访问的对象,就视为垃圾对象).  
GC扫描的起点根包括:栈上的引用(调用方法内引用),永生代上的类静态类型引用和常量区引用等  

### 回收算法  

#### 标记-清除算法  

算法分为标记,然后清除两部分  
这是最基础的算法了,后续算法都是针对标记清除算法的确定来演进的  
它的缺点  
* 效率不高  
无论标记过程,还是清除过程,效率都不高.效率不高,则意味着GC的耗时更长,停顿时间也更长  
* 会产生大量的不连续空间碎片,会导致可能分配不出一个连续的大对象空间而不得不提前触发一次GC  

#### 复制算法  

复制算法是将内存空间分为两块(各50%),每次GC都会把剩余对象全部移动到另一边 
这样分配时将使用在一块连续空间分配,效率更高
缺点  
* 内存天然只能使用一半,极大的浪费空间  
* 分配效率更高了,并且如果存活率相对高的话会导致GC过程更慢了   

#### 标记-整理算法  

与标记-清除相同,但清除完毕会将剩余对象全部前移成一个连续部分  

比复制算法的好处在于至少可以使用100%空间,但如果存活率依然有GC缓慢的特点  

#### 分代算法  

将堆分为几代(新生代和老年代),然后对每代分别使用不同的算法策略

###  GC产品  

#### Serial GC  

串行收集器是最古老,最稳定的收集器  
它是默认Client模式的新生代回收器  
串行收集器是一个单线程,在收集时会暂停整个JVM  


优点:
* 使用简单,对于单CPU,由于没有多线程的交互开销,可能会有奇效  

参数控制:

```java
-XX:+UseSerialGC  //串行收集器
会使用 Serial + Serial Old 的收集器组合  
新生代使用复制算法,老年代使用标记整理算法  
```

#### ParNew GC  

ParNew 其实就是 Serial 的多线程版本  

* 使用多线程进行GC,在GC时会停止整个JVM  
* 在并发能力好的环境下,它停顿的时间比串行要短,但如果环境本身的并发能力弱,由于多线程的交互开销,可能会比串行更差  
* 是Server模式的下默认新生代收集器,且能和CMS收集器配合使用  
* 新生代使用复制算法,老年代使用标记整理算法  

```java
-XX:+UseParNewGC 启用ParNew收集器
-XX:ParallelGCThreads 限制线程数量
```

#### Parallel GC 

Parallel 类似 PareNew 收集器,但Parallel更关注吞吐量.
可以通过参数来打开自适应调节策略,虚拟机会根据当前系统的运行情况收集性能监控信息,动态调整这些参数以提供最合适的停顿时间或最大吞吐量,也可以通过参数控制GC的时间不大于多少毫秒或者比例,比如新生代复制算法,老年代标记-压缩  

```java
-XX:+UseParallelGC 启用新生代Parallel GC
-XX:+UseParallelOldGC 启用老年代Parallel GC
-xx:GCTimeRadio 指定运行应用代码的时间占总应用时间的比例,默认99%,即1%时间用来GC
-xx:MaxGCPauseMillis:设置GC最大停顿时间  
新生代使用复制算法,老年代使用标记-整理算法
```

#### CMS GC  

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验  

CMS收集器是基于“标记-清除”算法实现的,整个步骤分为4步:  
* 初始标记（CMS initial mark）  
* 并发标记（CMS concurrent mark）  
* 重新标记（CMS remark）  
* 并发清除（CMS concurrent sweep）  

其中初始标记和重新标记两个阶段需要暂停整个JVM.  
* 初始标记仅仅只是标记下GC Roots能直接关联到的对象,会暂停整个JVM但速度很快,因为只扫直接关联  .
* 并发标记就是根据初始标记的直接关联对象继续扫描,在并发标记节点,JVM已恢复执行   
* 重新标记则是修正在并发标记期间,因用户程序继续运作而导致标记产生变动的那部分,这里会再次暂停JVM执行,并且这次暂停会比初始标记更长,但远比并发标记的时间要短.这就是CMS收集的设计优化思路,CMS认为,扫描一小段时间内的变化远比扫描一大段所花费的时间要短 
* 重新标记完成后,就会再次启动JVM,并并发的清除的标记对象 

优点:  
* 最低的停顿时间  
缺点:  
* CMS是无法立即进行整理工作的,所以会产生大量内存碎片空间.
* CMS的整理可以设置为GC几次后执行一次整理(整理过程必须暂停JVM) 

参数控制：
-XX:+UseConcMarkSweepGC  使用CMS收集器
-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

#### G1 GC

G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：

* 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC  
* 可预测停顿，这是G1的另一大优势  
降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了  

前面的垃圾收集器，收集的范围都是整个新生代或者老年代,而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合

首先G1会将整个内存空间分为很多很多大小相等的块,这些块有代的概念,即这些块分为新生代,老年代,但这些新生代和老年代彼此不一定保持连续 

新生代的搜集类似ParNew,当新生代占用达到一定的比例,开始触发搜集,和CMS类似,G1收集老年代会有短暂停顿  

收集步骤
* 标记阶段,首先初始标记(Initial-Mark),这个阶段是需要暂停JVM的,并且会触发一次普通Monitor GC,
* 

https://www.cnblogs.com/qingyunzong/p/8973857.html
