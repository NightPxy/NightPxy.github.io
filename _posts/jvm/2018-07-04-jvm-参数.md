---
layout: post
title:  "JVM-1.8-Hotspot 参数"
date:   2018-07-04 13:31:01 +0800
categories: jvm
tag: [jvm]
---

* content
{:toc}


# 概述    

JVM 的参数共分三种  
* -参数 标准参数  
这是JVM规范中定义的参数,会强制要求每个JVM实现都必须实现并保持兼容  
最常见的标准参数就是 `java -version`  
常用的还有verbos命令 `-verbose:class` 打印载入类相关信息,在JVM报告找不到类或类冲突时非常有用  
* -X参数 非标准参数  
也是JVM规范中定义,但不强制要求必须实现  
最常见的非标准参数 `-Xmx100m(堆最大) -Xms100m(堆初始) -Xmn100(年轻代)`  
* -xx参数 不稳定参数  
这就是纯粹由每个JVM实现的自定义参数了  
以Hotspot为例, `-XX:+PrintGCDetails(打印GC日志)`  

关于参数赋值  

* bool型  +打开 -关闭  
`-XX:+PrintGCDetails(打开) -XX:-PrintGCDetails(关闭)`  
* 数字型 直接设  
`-Xmx100m`  
* 字符串 =  
`-XX:HeapDumpPath=./java_pid.hprof`  

# 非标准参数  

|参数|描述|
|---|---|
|-Xmx100m|堆最大上限|
|-Xms100m|堆初始大小,一般设置与最大相同,避免GC回收后JVM重新分配内存来伸缩堆|
|-Xmn200m|年轻代大小(Eden+2个Survivor共计),官方推荐3/8,老年代自动=堆-年轻代|
|-Xss128k|线程栈大小,1.5后默认1M.更少的线程栈可以产生更多线程(但受操作系统上限)|
|-Xloggc:file|将每个状态记录如文件中(带时间戳)|
|-Xdebug||

# 不稳定参数   

|参数|描述|
|---|---|
|-XX:SurvivorRatio|用于设置Eden和两个Survivor的比值,默认为8(Eden):1:1(1/10)|
|-XX:MaxMetaspaceSize=10M|设置元空间最大为10M,默认无限制|
|-XX:-UseParallelGC|启用并行GC|
|-XX:-UseSerialGC|启用串行GC|
|-XX:-UseConcMarkSweepGC|对老年代采用并发标记交换算法进行GC|
|-XX:-DisableExplicitGC|禁止代码调用System.gc,JVM的GC依然有效|
|-XX:MaxNewSize=N|新生代对象能占用内存的最大值|
|-XX:MaxPermSize=64M|老年代对象能占用内存的最大值|
|-XX:NewSize=2.125m|新生代对象生产时占用内存的默认值|
|-XX:ThreadStackSize=512|设置线程栈大小,为0表示使用系统默认值|
|-XX:HeapDumpPath=./java_pid<pid>.hprof|指定导出堆信息时的路径或文件名|
|-XX:-HeapDumpOnOutOfMemoryError|当首次遭遇OOM时导出此时堆中相关信息|

SurvivorRadio  
-XX:SurvivorRadio=4,表示Eden区与Survivor区的比值为4,但因为Survivor实际有两个,所以其具体比例为4:1:1,即Eden占4/6,每一个Survivor占1/6  

GC执行三种方式,串行(Serial),并行(Parallel),并发(ConcMarkSweep)  
* 串行是client版的默认,GC与App互斥,即整个GC都会停顿  
* 并行是Server版的默认,GC与App两者线程并行执行,但此时GC线程本身是单线程  
* 并发是并行的升级版,GC本身就以多线程执行  

# 调优经验   

## 堆代空间  

堆代空间本身会极大的影响到GC,并且调优相对GC参数更为简单,如果堆代调优后能解决问题最好,所以首先考虑的是堆代空间调优  

堆代空间最重要的是堆代平衡.过于极端的堆代空间调整往往效果都非常差  
* 堆代过小   
年轻代过小在晋升时因为自身无法存入时跳过年龄线直接晋升老年代.这会到导致一些可能快速丢弃的瞬时对象被错误晋升到老年代并积压老年代空间.又会继续造成MajorGC甚至FullGC   
老年代过小也是同理,只要老年代自身无法继续存入就会触发MajorGC甚至FullGC,甚至会直接出现OOM  
* 堆代过大   
堆代也不应设置过大.无论年轻代过大还是老年代过大,越大意味着单次GC扫描的对象越多,那么每次停顿时间也会变长  

所以堆代调优的核心在于平衡,在于根据应用程序的用途和执行过程,配合GC日志反复实验找出平衡点   

一些可以参考的关于堆代参数的原则如下  

**堆**  

* 依据JVM的目标机器,给定一个合适的堆空间  
因为堆并非越大越好,JVM的目标机器也是堆设定的一个重要参考   
一般来说,32位机堆上限不超过2G,64位的4G起步.原则上单个JVM上限不超过32G(超过32G会造成压缩指针失效,造成极大的内存浪费,后文详述)  
* -Xmx与-Xms 即堆的最大空间和初始空间设为一致  
这样的目的在于防止GC内存回收后,JVM再行依据初始空间伸缩堆   
*  如果有大量的反射与运行时加载情况,必须将方法区消耗纳入考虑范围  

**年轻代**  
年轻代是影响响应速度最重的地方  
* 设置年轻代的总大小 `-XX:NewSize=N -XX:MaxNewsize=N -XX:NewRatio=N`  
基于同样的原因,年轻代的初始和最大可以设置为一样.   
原则上年轻代配置必须小于老年代.因为必须考虑一个极端情况就是年轻代的整体晋升   
主要的权衡点在于,调低年轻代可以降低MinorGC的单次时长,但会增加MinorGC的频次.  
注意在某些场合比如G1,应该刻意避开手动干预年轻代防止覆盖G1的自适应优化(后文详述)  
* 还可以更加细化的干预年轻代的Eden和两个Survivor  `-XX:SurvivorRatio`   
伊甸园区和幸存者区比例也是一个比较重要的优化点.理想情况下,我们当然希望在一次MinorGC后同时清理掉伊甸园和幸存者区.但事实每次MinorGC总会剩下相当于一部分.此时伊甸园区剩下的和幸存者区会进入另一个幸存者区,而每一个幸存者在经历一次转区后年龄增长一岁,直到达到年龄线后晋升入老年代   
而问题往往体现在.如果存在大量幸存者而幸存者区又放不下的时,会将幸存者直接忽略年龄直接晋升,其次如果幸存者是一个相对瞬时对象(相对不长又相对长的),也会导致大量幸存者因为达到年龄线也自动晋升老年代.这两种情况的后果都是,让一些我们不想其升入老年代的对象大量涌入老年代  
解决这个问题的办法就是干预幸存者区和伊甸园的大小.  
结合年龄对象分布`-XX:+PrintTenuringDistribution`  
如果分布大量的低年龄对象,说明很多幸存者区设小了,此时就可以调大幸存者区   
如果分布大量的高年龄对象,说明幸存者足够是自然晋升,此时可以调大晋升年龄线  
* 老年代  
* 方法区  
  


# 分享网上一个牛人的参数调优  

该牛人主要使用的CMS,Web项目每天几百万PV感觉不到任何停顿,值得借鉴和参考  

```shell
-Dresin.home=$SERVER_ROOT
-server
-Xms6000M  
-Xmx6000M #堆初始和最大都设置6G,这样可以避免GC之后内存释放导致JVM重新伸缩堆
-Xmn500M #年轻代设置相对偏小,用大量微MinorGC来换取停顿时间变短
-XX:PermSize=500M  
-XX:MaxPermSize=500M # 永生代初始和默认都500M,也可以减少堆伸缩
-XX:SurvivorRatio=65536
-XX:MaxTenuringThreshold=0
-Xnoclassgc
-XX:+DisableExplicitGC
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+UseCMSCompactAtFullCollection
-XX:CMSFullGCsBeforeCompaction=0
-XX:+CMSClassUnloadingEnabled
-XX:-CMSParallelRemarkEnabled
-XX:CMSInitiatingOccupancyFraction=90
-XX:SoftRefLRUPolicyMSPerMB=0
-XX:+PrintClassHistogram
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-XX:+PrintHeapAtGC
-Xloggc:log/gc.log
```

