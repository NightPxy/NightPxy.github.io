---
layout: post
title:  "JVM 内存"
date:   2018-07-01 13:31:01 +0800
categories: jvm
tag: [jvm]
---

* content
{:toc}


## 概述  

### 

前文已说明,GC的主要工作对象就是堆,而堆的内存结构就是4块.Young代(Eden,S0,S1)+Old代    
之所以如此划分堆区,就是为了GC服务的  

在GC设计中有一个原则,就是大部分的对象都是短命对象.即创建出的对象,都将很快就不被使用了.而使用时间越长的对象,往往会使用的越频繁  

### STM  

STM(Stop The World) 是GC中的专业术语.  
它描述的是,在GC过程中,不得不暂停所有的应用线程.此时对应用来说,就好像世界被停止一样  

## GC类别  

### MinorGC  

如果在新生代分配不出一个对象内存,就会触发一次新生代GC.这种GC,就称为MinorGC  
因为绝大多数新创建的对象都会被分配到Eden,所以MinorGC是最容易发生的GC.  
而新生代中的对象每活过一次GC,就代表它越容易被使用,就会升一代,直到到达老年代  

整个过程  
* 对象持续分配Eden,如果Eden分配不出来内存,就会触发MinorGC  
* MinorGC首先清理Eden,然后将Eden活下来全部搬运给S0  
* 如果此时S0也满了,就清理S0,然后全部搬入S1,直到S1也满,就丢入老年代    
* 每次MinorGC后,都可以得到一个从头开始的Eden,然后继续分配  

### MajorGC  

MajorGC就是老年代中存放的GC  
老年代的对象一般都是存活很久,有很高几率还会继续使用的对象,所以触发MajorGC相对不频繁,一定是在MinorGC无法解决的时候才会触发  
相对的,MajorGC的代价消耗也更高,因为老年代一般对象都很多,并且垃圾率并不高  

### FullGC

FullGC是一种比较特殊的GC,就是同时对新生代和老年代执行GC  
FullGC一般发生在  
* 程序手动触发执行 System.gc  
* MinorGC 到 MajorGC,但是发现老年代也存储不下.这是FullGC清理整个堆区,做最后的尝试  
如果FullGC后仍然不能分配对象,就会抛出OOM了  

## GC回收算法   

### 标记-清除算法  

算法分为标记,然后清除两部分.这是最基础的算法,后续算法都是针对标记清除算法缺点来演进的  

### 复制算法  

复制算法是将内存空间分为两块(各50%),每次GC都会把剩余对象全部移动到另一边   
这样分配时将使用在一块连续空间分配,效率更高  

缺点  
* 内存天然只能使用一半,极大的浪费空间  
* 分配效率更高了,并且如果存活率相对高的话会导致GC过程更慢  

### 标记-整理算法  

与标记-清除相同,但清除完毕会将剩余对象全部前移成一个连续部分  
比复制算法的好处在于至少可以使用100%空间,但如果存活率高依然有GC缓慢的特点  

### 分代算法  

针对不同的特点,将堆分为几代然后对每代分别使用不同的算法策略  

## GC 产品  

### SerialGC SerialOldGC   

***概述***
串行收集器是最古老,最稳定的收集器,也是Client模式的默认GC方式   
串行收集器是一个单线程,在整个GC过程都会STM  

***优点***  
* 使用简单,对于单CPU,由于没有多线程的交互开销,可能会有奇效  

***缺点***  
* 整个GC过程STM,往往太不可接受了  
* 单CPU的优势,很难谈的上,毕竟现在单核机器,已经相当稀有了  

### ParNewGC  ParNewOldGC  

***概述***
就是SerialGC的多线程版,也是Server模式的默认GC方式   
虽然是多线程GC会缩短GC时间,但在整个GC过程还是会STM  

***优点***  
* 相比SerialGC,GC过程会更短   

***缺点***  
* 整个GC过程STM,还是不可接受  

***参数***

```java
-XX:+UseParNewGC 启用ParNew收集器
-XX:ParallelGCThreads 限制线程数量
```

### CMS GC 

***概述***
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验  

***回收步骤***
CMS收集器是基于“标记-清除”算法实现的,整个步骤分为4步:  
* 初始标记（CMS initial mark,STW）  
初始标记扫描Roots能直接关联的对象,这一步比较快,但会STW  
* 并发标记（CMS concurrent mark）  
并发标记是根据初始标记的标记对象继续扫描.并发是指不会STW,用户线程会继续执行
* 重新标记（CMS remark, STW）  
重新标记是修正在并发标记节点用户线程继续执行所产生的引用变更等情况的修正.  
会STW,且时间一般会长于初始标记停顿,但远小于整个并发标记的时间  
* 并发清除（CMS concurrent sweep）  
根据修正后的标记开始清理,不会STW,用户线程会继续执行  

***优点***
* 最低的停顿时间  
使用于要求高响应速度,不能接受稍长的系统停顿时间的情况  

***缺点***
* 会产生大量内存碎片空间  
CMS是无法立即执行内存整理,所以会产生大量内存碎片.只能在GC N次或者老年代满的情况下以STW的方式内存整理  
* 在并发标记和并发清理阶段,多线程会占用一定CPU资源而导致可能的应用程序吞吐量下降  
默认GC线程数量是 (CPU个数+3)/4 即2核1个,5核2个  
* 会产生浮动垃圾,且当突然产生大量浮动垃圾时会分配失败,此时会被迫启用seral-old重新GC  
浮动垃圾是指在CMS在并发清除阶段,因为用户线程的继续执行而产生的新的垃圾.这部分垃圾无法在本次GC中处理(甚至都不一定开始清理),所以只能放入预留空间.  
但如果某个时刻用户线程产生了大量的对象,而导致预留空间放不下,此时会启用seral-old重新GC(STW)
* CMS基于标记-清理的算法实现的，所以会导致old-Gen内存碎片。当内存碎片过多或者年轻带晋升太多,CMS未完成时oldGen已经满了，则会产生concurrent mode failure 然后切换为SerialOld(mark-sweep-compact 带整理内存碎片)  

***常用优化***

*-XX:+UseConcMarkSweepGC*  
使用CMS收集器

*-XX:CMSInitiatingOccupancyFraction=70*  
设定CMS在对内存占用达到70%的时候开始GC(因为CMS会有浮动垃圾,所以一般都较早启动GC)   
*-XX:+UseCMSInitiatingOccupancyOnly*  
只是用设定的回收阈值(上面指定的70%),如果不指定,JVM仅在第一次使用设定值,后续就失效了  

*-XX:+CMSScavengeBeforeRemark*  
在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销  
一般CMS的GC耗时 80%都在remark阶段  

*-XX:+CMSFullGCsBeforeCompaction*  
设置进行几次Full GC后，进行一次碎片整理  

*-XX:ParallelCMSThreads*  
设定CMS的线程数量（一般情况约等于可用CPU数量）  