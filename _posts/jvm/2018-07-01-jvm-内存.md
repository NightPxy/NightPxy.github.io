---
layout: post
title:  "JVM 内存"
date:   2018-07-01 13:31:01 +0800
categories: jvm
tag: [jvm]
---

* content
{:toc}


# 概述  

JVM的内存结构,主要分为以下几块  

* 程序计数器(program counter register)  
* 栈区(Stack)
* 堆区(Heap)
* 方法区(Method Area)  

# 程序计数器  

程序计数器用来存储某个线程当前执行到的字节码行号  
多线程情况下,JVM就是依靠这个计数器在切换线程上下文时保证可以恢复到上次执行的地方  
所以程序计数器是每个线程都会私有一个自己的行号,并且程序计数器是唯一一个不会发生OOM的地方,程序计数器属于GC工作对象  

# 栈区  

JVM中的栈区其实分为两部分  JVM栈和本地方法栈  
栈区存储都是线程私有的,并且整个栈区都不属于GC工作对象  
对栈来说,如果超出JVM允许的栈最大深度,会抛出StackOutFlow异常  

## JVM栈  

JVM栈是JVM的执行过程抽象,每一个方法执行时都会生成一个栈帧(Stack Frame)  
栈帧存储的是执行方法时的局部变量,操作数栈,动态链接,方法出口等  
JVM每个方法从调用到执行完成的过程,就是产生一个栈帧并从JVM入栈到出栈的过程  
也就是说 栈帧的入栈出栈=方法执行的开始和结束  

注意:  
局部变量存储的是编译器可知的各种基本数据类型(boolean、 byte、 char、 short、 int、float、 long、 double)和对象引用  
所以如果方法内局部变量对象,这个对象本身依然是存储在堆上,只是在局部变量中压入对象的引用(指针)

一个面试题: 

```java
public static void main(string[] args){
  //局部变量,但局部变量区只会存入v的引用,v的实际存储在常量区 
  String v = "abc"

  //局部变量,这个就比较麻烦了
  //首先局部变量区的引用存储的是堆上的对象的指针
  //而堆上的对象里面再存一个常量区的引用
  String v = new String("abc")
}
```

## 本地方法栈  

本地方法栈与JVM栈没有本质区别,只是JVM用来执行一些本地语言执行方法  

# 方法区  

方法区存储的是类的类型&方法信息,静态变量以及常量区  
方法区的数据是线程共享的  
方法区有OOM情况,但方法也不属于GC工作对象.方法区有自己回收机制:类型加载和类型卸载 

方法区还有一种称呼为永生代,这是将方法区认为是堆的一个组成部分  
这种说法也没问题,方法区的确有很多与堆相同的特征,比如线程共享,有内存分配与OOM等等,但是方法区,或者说永生代,不归GC负责,这一点切记  

# 堆区  

堆是JVM中最大的一个区,也是GC的主要工作对象.

## 堆对象创建  

所有的对象,数组等等都在堆上创建  

***对象的组成***  
* 对象头  
用于存储对象自身的运行时数据.如哈希码,GC分代年龄,锁状态,线程持有锁,偏向线程ID,偏向时间戳等,还有对象的类型指针,数组的话还有长度等等  
* 对象实例数据  
对象真正存储的有效信息，引用类型、基本类型  
* 填充物  
java中数据类型必须是byte的整数倍,通过“对齐填充”来保证,也就是占位符填充物  

***对象的创建***  
1. 确保类型已加载,如果没加载就加载类型  
2. 确保对象所属类型已经经过初始化阶段  
3. 分配内存  
TLAB（Thread Local Allocation Buffer,TLAB） 或者通过CAS锁直接在eden中分配对象  
4. 如果需要,则对象初始化零值
5. 设置 对象头Header  
6. 如果有引用，将该对象引用放入栈中  
7. 对象按照程序员的意愿进行初始化（构造器）  

在3,6,7中,对象初始化后接着分配引用,这时虽然拿到了引用,但是对象初始化并未完成,所以double check 如果不使用 volatile 就会出现问题的原因   

***对象分配内存方式***  

* 直接移动指针划分需要的内存((通过CAS方式保证其他线程不会并行的使用该内存)  
* 预先对每个线程划分一小块可使用的内存,这个线程中的对象初始化时则直接使用这一小块内存,直到预先分配的内存使用完,再去使用CAS锁去Heap中分配新的内存(-XX：+/-UseTLAB 设置)  

## 堆的内存结构  

HotSpot将堆内存(这里不包括方法区,或者说永生代),分为两大块  
* 新生代(Young)
新生代内部再分为(Eden,S0,S1)三个部分,默认为8:1:1  
* 老年代(Old)  

所以堆的内存结构就是4块.Young代(Eden,S0,S1)+Old代  
堆的内存结构要配合GC说明,详见下章  

