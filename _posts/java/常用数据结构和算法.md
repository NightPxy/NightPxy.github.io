---
layout: post
title:  "常用数据结构和算法"
date:   2019-01-03 13:31:01 +0800
categories: java
tag: java
---

* content
{:toc}

## 基本数据结构   

### 数组  

数组是两大最基本的数据结构之一  
数组的本质一个数据连续存储的内存空间  

数组的优势  
* 适于遍历(自带免费的缓存行加载)  
* 下标读取O(1)  
* 基本没有内存损耗  

数组的劣势  
* 非尾段插入必须移动大量的元素O(n)(尾段插入还是O(1))  
* 数组只能是定长,如果要实现变长必须扩容O(n)  

### 链表  

链表是两大最基本的数据结构之一  
链表的本质是一个数据离散存储的内存空间  

链表的优势  
* 任意段位插入都是O(1)(双向链表)  
* 天生变长,没有扩容消耗  

链表的劣势  
* 遍历相比数组消耗更大(每一个元素都是缓存行读取)  
* 下标读取只能依赖遍历O(n)  
* 有大量的内存损耗(链表元素封装和前后驱指针等)  

链表常用操作  

```java

//遍历
//判断是否有环  
//就地反转  
```


## 偏动作  

### 栈  

栈是一种维持先进后出的数据结构   
* 链表实现  
维持一端进出即可  
* 数组实现  
数组实现一般为RingBuffer,然后使用单游标  


```java
val stack = new LinkedList()
//头端进
stack.push(x)
//头端出
stack.poll()
```

### 队列  

队列是一种维持先进先出的数据结构  
* 链表实现  
维持头端出,尾端进即可  
* 数组实现  
数组实现一般为RingBuffer,然后使用双游标(头,尾)  

## 偏查找  

### 哈希  

哈希的本质是数组  
哈希是一种查找向结构,它的本质是依赖数组的下标读取O(1)  

哈希的优势是O(1)查找  

哈希的劣势  
* 数组本质带来的扩容消耗  
* 哈希带来无可避免的哈希冲突  

以`HashMap`为例的哈希优化  
* 基于2幂的数组容量保持  
2幂本身不是哈希要求,但采用2幂之后,可以用位运算来替代哈希码定位  
常规哈希定位`idx= hashcode % array.length`(转十进制多次除法)  
位运算定位`idx= hashcode & (array.length-1)`(位移即可)  
2幂的另一个优势是可以预见扩容后位置  
* 用空闲因子来减少哈希冲突  
`HashMap`默认为0.75,即只使用四分之三为数组空间来存储  
* 用提前声明来尽可能防止扩容  
在`HashMap`构造中可以传入元素数量  
元素数量应考虑空闲因子`Count=(期望数量 / 0.75)+1`   
* 哈希扰动  
用哈希扰动来进一步降低冲突几率  
扰动算法 `hashcode = hashcode ^ (hashcode >> 16)`  

尽管使用了空闲因子,哈希扰动等等手段来减少哈希冲突几率  
但哈希冲突时永远也无法避免的,最终解决思路有   
* 拉链法
拉链法 `HashMap`哈希冲突中槽位转为链表(大于8时转为红黑树)  
* 二次寻址法  
Spark `AppendOnlyMap`使用的二次寻址法  
核心思路是不断寻址(基于Seed累加)来不断寻找一个空闲位置  
二次寻址的优势是始终维持数组结构(适应排序)  
二次寻址的劣势是不能有删除行为(只能标记删除),且二次寻址有理论上无法解决冲突可能  

### 树  

树是偏查找的数据结构,它的核心本质是二分查找Log(N)   

#### 二叉树

二叉树的定义非常多  
* 满二叉树  
最后一层没有任何节点,其它每个节点都有完整的左右子节点  
* 完全二叉树  
每一层都已达到节点最大数,如果不能,节点也是全部连续集中在最左边  
个人理解的完全二叉树的本质是满二叉,只是因为数据元素个数不足的问题,导致不能完全满足每个节点都有完整的左右子节点  

二叉树的用途是为了适应二分查找,所以树完全程度越高,查找的效率也就越高  
如果树完全只在单边放入,就会退化成链表而失去二分查找的优势  
所以引入`平衡`来描述完全程度  
* 平衡二叉树  左右子树的层级高差不超过一  
* 红黑树  





#### B树   

B树,是一种N叉树,是一种大数据量下的查找解决方案  
大数据量指的是内存不能存放一颗完整树,也就是说读取树节点将不得不借助IO来实现部分读取  
在内存不能存放一颗完整树情况下,包括红黑树在内的树层级过深(层级越深,就代表可能的IO越多(因为内存不能容纳而只能走磁盘IO,而非内存读取)  

B树中又分为B树,B+树  
* B树  

#### 前缀树  

### 跳表   

### 堆  



















