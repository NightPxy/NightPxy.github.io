---
layout: post
title:  "锁"
date:   2018-07-01 13:31:01 +0800
categories: java
tag: [java]
---

* content
{:toc}

## 锁分类  

按照不同维度,或者说不同的视角.锁可以分为许多类别  

### 乐观锁 & 悲观锁  

**乐观锁**  
乐观锁,是对并发锁的乐观估计.即认为实际过程中并发写几率无或很低  
乐观锁本质上就是无锁.它是提前取出类似版本号之类的,然后在提交时去比较版本号看是否发生变更,如果不匹配则不更新,并交给提交方选择诸如重试或抛出异常等不同策略  

**悲观锁**  
悲观锁,是对并发锁的悲观估计.即认为实际过程中并发写非常高  
悲观锁就是我们通常意义上的并发锁.它会在写之前提前独占资源,直到完成后再重新释放资源  

###  重量锁 & 轻量锁 &偏向锁 & 混合锁   

**重量锁**  
重量锁,或者说内核锁.是一种操作系统级别的锁  
也就是它的锁是发生在操作系统层面,这时的锁是真正的锁,会触发操作系统级别的线程切换  
比如JDK1.5之前的synchronized,就是一种重量锁,会发生操作系统级别的线程切换  

**轻量锁**  
轻量锁,或者应用锁.一种应用程序级别的锁  
也就是它的锁是发生在应用程序级别层面,这时的锁不是真正的锁,而是一种应用程序的模拟.所以不会发生操作系统级别的线程切换  
轻量锁的本质是一种自旋锁的实现,它是在自造循环监视同步块,尝试抢占.一旦抢占成功就标记同步块,即视为抢占成功  

**偏向锁**  
偏向锁本质上是一种非并发锁.  
它是指如果不存在争夺情况(即始终只有它自己在用),就可以直接偏向锁进入  
偏向锁依然会标记同步块,一旦有第二个线程开始尝试争夺,偏向锁会立即升级为轻量锁(因为不止它一个用了,那就找轻量锁自旋来,大家争夺)  

**混合锁**  
就是重量锁和轻量锁的混合版本.  
比如JDK1.5之后的synchronized就是一种混合锁.它的实现是先尝试轻量锁(自旋锁)一段时间,失败之后再转入重量锁  

*锁与同步块*
*锁膨胀*  

### 死锁 & 活锁

**活锁**  
活锁是指没有被阻塞,但由于某些条件没有被满足一直重试  

*活锁的危害*    
活锁是一种务必要注意的地方.活锁空转CPU,即浪费CPU能力又实际不产生任何价值,但又不会抛出任何异常很难排查  
但某些情况活锁是可能出现的.本质上,自旋锁就是一种活锁.活锁一定要注意的是必须保证在某个条件满足时能够退出,并且保证这种退出条件是可以被出现的.

**死锁**  
出现两个或多个线程,因为争夺资源而互相等待对方释放  

*死锁的四个必要条件 *  
* 互斥  
资源是独占且排它.线程本身占有的资源无法同时分享给其它线程  
* 占有并等待  
线程已占有的资源并未完全,必须等待另外部分资源  
* 无法被剥夺  
线程已占用的资源也无法被其它线程剥夺,必须等待线程自身释放  
* 循环等待  
两个线程所占有和欠缺的资源,刚好处在对方线程  

*破坏死锁条件而避免死锁*  

* 破坏互斥  
资源是非互斥状态则不会产生死锁.比如各自持有独立副本  
* 破坏占有并等待  
因为只持有部分资源而必须等待.可以一次性分配全部所需资源而避免等待  
* 破坏无法被剥夺  
存在一个第三方的超级线程,在满足一定条件的情况下强行释放死锁线程已占用的资源  
* 破坏循环等待  
合理的调度顺序,破坏循环等待对方的情况  


