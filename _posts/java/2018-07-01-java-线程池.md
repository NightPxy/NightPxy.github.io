---
layout: post
title:  "线程池"
date:   2018-07-01 13:31:01 +0800
categories: java
tag: [java]
---

* content
{:toc}


# 线程池  

线程池的优势  
* 线程是一种昂贵的资源.创建和销毁都是非常昂贵的.所以需要线程池来更好的减少和复用线程  
* 提前初始化一部分线程,可以跳过从头创建从而快速申请到执行  
* 对线程的总体数量进行把控,避免过度开启线程   

# 线程池的原理和执行流程  

线程池一般由 **工作线程池** 和 **阻塞队列** 两大部分组成  
* 工作线程池   
包含线程池中实际执行的所有线程.一般会有初始数量(期望数量)和最大数量对其进行控制  
* 阻塞队列  
所有执行单元的提交,都会由阻塞队列进行暂存.阻塞队列一般有规定上限,以及达到上限如何处理的拒绝策略等  

所有整个线程池的执行流程是  
* 初始化线程池.提前创建部分线程(接近期望数量)  
* 阻塞队列等待接受执行单元.一旦收到执行单元就会尝试加入阻塞队列.如果此时阻塞队列已达到上限,就会立即交给拒绝策略决定如何处理
* 然后按照阻塞队列的策略(例如FIFO),在工作线程池中找一个空闲的线程进行执行. 
如果工作线程池中找到一个空闲线程,就会标记这个线程并使用这个线程进行执行  
如果已经没有空闲线程,就会检查是否工作线程池上限.如果没有达到上限就会创建一个新线程加入工作线程池并执行.如果达到上限,阻塞队列就会等待直到能有线程被空闲  
* 工作线程池本身会定时检查空闲线程,如果达到最大空闲时间依然没有任务执行就会销毁,直到工作线程池数量最终慢慢回归到期望数量  

# 线程池的实现  

## ThreadPoolExecutor  

### 线程池签名  
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```
**corePoolSize**  
线程池的期望线程数.在空闲时,线程池最终会慢慢回到期望线程数  

**maximumPoolSize**  
线程池最大线程数  

**keepAliveTime & unit**  
空闲线程的保留时间 & 空闲线程保留时间的单位
超出期望线程数(CorePoolSize)的线程,会在该时间后被自动销毁  

**workQueue**
阻塞队列
每个提交的执行单元都会进入阻塞队列缓存,再由线程池决定何时使用哪个空闲线程进行执行  
阻塞队列可以设置上限,在达到上限后继续进行提交就会触发拒绝策略  
阻塞队列有几个可选实现:  
* ArrayBlockingQueue 有界队列 
由数组实现的阻塞队列,FIFO.数组实现,需要指定队列数量,是为有界队列  
* LinkedBlockingQueue 无界队列  
由链表实现的阻塞队列,FIFO,链表实现,默认以Integer.MAX_VALUE,是为无界队列
* SynchronousQueue 无队列(无界队列)  
不使用(上限为0)的阻塞队列,当提交后将立即寻找一个工作线程执行,如果没有找到会立即创建  
* PriorityBlockingQueue  
按照优先级阻塞

**threadFactory**  
线程创建工厂  
如果线程池没有达到上限又提交了新的执行单元,就会使用该工厂创建一个线程加入线程池并执行  

**RejectedExecutionHandler handler**  
执行拒绝策略  
在提交执行单元到阻塞队列时,如果达到阻塞队列上限,就按该拒绝策略决定如何执行  
可选的拒绝策略有  
* AbortPolicy(默认)  
拒绝后直接抛出异常告知调用者  
* CallerRunsPolicy 使用调用者  
拒绝后不使用线程池执行,而是交回调用者线程池执行  
* DiscardOldestPolicy 抛弃队列中最久的任务  
拒绝后丢弃最老的执行单元,然后重新加入队列  
* DiscardPolicy 抛弃当前任务  
拒绝后直接丢弃当前任务.不抛出异常  



### 线程池的关闭  



https://zhuanlan.zhihu.com/p/33264000
https://blog.csdn.net/qq_25806863/article/details/71126867
https://blog.csdn.net/wang_rrui/article/details/78541786


