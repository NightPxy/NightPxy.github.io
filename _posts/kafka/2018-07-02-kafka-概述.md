---
layout: post
title:  "kafka 概述"
date:   2018-07-01 13:31:01 +0800
categories: kafka
tag: [kafka]
---

* content
{:toc}


##  概述  


##  架构   

### Topic  

主题（Topic），kafka对消息类别的划分  
这种类别划分是物理隔离的,也就是不同topic的数据是完全隔离在不同数据文件夹中的.  
但是topic又是kafka的一种逻辑概念,它不负责具体的消息处理.而是交由topic下的分区来具体执行.  
一个topic下总是会包含一个或多个分区,并且kafka会自动维护一个分区日志.  
而分区下的数据以commit-log的形式进行存储,无论消息是否被消费,kafka总是会持续保存log数据,直到到达消息的最大过期时间  

### Partiotion  

对一个Topic下的水平切分,每一个切分块就是一个分区(Partition)  
分区是一个顺序的,不可更改但可以持续追加的消息队列.  

分区好处有  
* 理论上的无限数据存储,只需要增加分区就可以了  
* 提供消息处理并行度.每个分区都可以作为一个并行的单元集  

分区中每一个消息都被分了一个序列号,称之为偏移量(Offset),在每个分区中,消息偏移量保持唯一  
消息的顺序读取是依赖分区偏移量来实现的,这个偏移量是由消费者控制的,这意味着  
* 消费者依靠重置偏移量,可以反复重新读取消息  
* 消费者的任何读取,不会影响到其它消费者.因为每个消费者都持有自己独立的偏移量

### 副本与分区容错性    

数据存储log将以副本的形式分散存储到kafka集群中.每个服务器也只处理在它本机上的数据   
所以在分区中,只有一个leader被选举成为主服务器,其余节点都将作为follow服务器  
在同一时刻,是始终由leader作为消息收发的主体.其它follow服务器只是被动的同步数据.一旦检测到leader挂掉了,将按照顺序(选举leader时就会同时产生follow接管顺序),由下一位的follow的接管成为leader而继续提供服务  


### Broker  

Broker 是kafka的服务器进程.
在kafka集群中,每一个服务器都是一个Broker,消费者也是基于Broker来拉取订阅消息  

### Producer  

消息的发生者(生产者).

### Consumer

消息的处理者(消费者),负责订阅和消费消息  
消费者有组的概念(ConsumerGroup).每个组有一个唯一ID(ConsumerGroupId)  

***同一个消费组***  

整个消费组会联合起来共同消费topic下的所有分区  
对同一个消费组而言,消息记录会被负载均衡到每一个消息实例

*注意:消费组本质上一种可扩展的容错机制,而不是提升性能的手段 *  
* 如果某一个消费者实例宕机,会将这个分区交给这个消费组内其它某一个消费者实例   
* 任何时间,每个分区都只会分配到一个实例上  
所以多开消费者实例(大于分区数),只会造成空闲,没有任何意义


***不同消息组而言***  

消息记录会被广播到所有的消息组中  

总结  
* 同一个消费组可以消费多个分区的消息  
* 同一个分区也可以由多个消费组消费  
* 但是,在一个消费组内部,一个分区只能由一个consumer消费  


https://www.cnblogs.com/heidsoft/p/7697974.html
https://www.tuicool.com/articles/Ajau6fr
https://zhuanlan.zhihu.com/p/43843796


## kafka的优缺点  

### 

